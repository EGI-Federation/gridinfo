#!/usr/bin/env python

import ldap
import sys
import getopt
import json
import os

VERSION = '0.9'
conf = {}

# option: [short_option, parameter?]
options = {
    'host': [None, True],
    'list': ["l", True],
    'csv': ["c", False],
    'json': ["j", False],
    'emi': ["e", False],
    'verbose': ["v", False],
    'version': ["V", False],
    'help': ["h", False],
    'cap': [None, True],
    'domain': ["d", True],
    'id': ["i", True],
    'imp': ["m", True],
    'impv': [None, True],
    'int': ["n", True],
    'intv': [None, True],
    'ql': ["q", True],
    'type': ["t", True],
    'url': ["u", True],
    'vo': [None, True],
    }
# attribute for the ldap request: [pre_objectClass, objectClass, key, result_as_list]
attributes = {
    'cap': ['', 'Endpoint', 'Capability', True],
    'domain': ['', 'Service', 'AdminDomainForeignKey', False],
    'id': ['', 'Service', 'ID', False],
    'imp': ['', 'Endpoint', 'ImplementationName', False],
    'impv': ['', 'Endpoint', 'ImplementationVersion', False],
    'int': ['', 'Endpoint', 'InterfaceName', False],
    'intv': ['', 'Endpoint', 'InterfaceVersion', False],
    'ql': ['', 'Endpoint', 'QualityLevel', False],
    'type': ['', 'Service', 'Type', False],
    'url': ['', 'Endpoint', 'URL', False],
    'vo': ['Access', 'Policy', 'Rule', True],
    }
# Keys that link objects to Endpoint object [objectKey, EndpointKey]
objectKey = {'Service': ['ID', 'EndpointServiceForeignKey'], 'AccessPolicy': ['EndpointForeignKey', 'EndpointID']}

def main(argv):
    """Main function that launches the other functions""" 

    if 'LCG_GFAL_INFOSYS' in os.environ:
        conf['host'] = os.environ['LCG_GFAL_INFOSYS']
    parse_options(argv)
    validate_conf()
    if 'list' in conf:
        list = list_attr()
        print '\n'.join(list)
    else:
        dic = list_services()
        print serialize_output(dic)
    sys.exit()

def parse_options(argv):
    """Parses the selected options and pouts them in a configuration dictionnary""" 

    short_options = ''
    long_options = []
    tmp_list = []
    for i in options:
        if options[i][0]:
            short_options += options[i][0]
            if options[i][1]:
                short_options += ':'
                long_options.append(i+'=')
            else:
                long_options.append(i)
        elif options[i][1]:
            tmp_list.append(i+'=')
        else:
            tmp_list.append(i)
    long_options.extend(tmp_list)
    try:
        opts, args = getopt.getopt(argv, short_options, long_options)
    except getopt.error as e:
        if e.opt in ("l", "list"):
            sys.exit(list_usage())
        else:
            sys.exit(usage())
    #options
    for opt, arg in opts:
        opt = opt[opt.rfind('-')+1:]
        for i in options:
            if opt in (i, options[i][0]):
                if options[i][1]:
                    conf[i] = arg
                else:
                    conf[i] = True
                continue
    #arguments
    conf['args'] = args
    if len(args)==0:
        conf['args'] = attributes.keys()

def validate_conf():
    """Prints verbose messages and checks for errors""" 
        
    #options
    if 'help' in conf:
        print usage()
        sys.exit()
    if 'version' in conf:
        print os.path.basename(sys.argv[0]) +' V'+VERSION
        sys.exit()
    if 'csv' in conf and 'json' in conf and 'emi' in conf:
        sys.exit('Error: choose between csv, json and emi.')
    elif 'csv' in conf and 'json' in conf:
        sys.exit('Error: choose between csv and json.')
    elif 'csv' in conf and 'emi' in conf:
        sys.exit('Error: choose between csv and emi.')
    elif 'emi' in conf and 'json' in conf:
        sys.exit('Error: choose between json and emi.')
    elif 'csv' in conf:
        if 'verbose' in conf:
            print 'Output in csv formating'
    elif 'json' in conf:
        if 'verbose' in conf:
            print 'Output in json formating'
    elif 'emi' in conf:
        conf['args'] = ['url','type', 'domain', 'cap', 'int', 'intv', 'ql']
        if 'verbose' in conf:
            print 'Output in emi formating'
    if 'host' in conf:
        if 'verbose' in conf:
            print 'The following host will be used:',conf['host']
    else:
        sys.exit(usage())
    if 'list' in conf:
        if conf['list'] not in attributes.keys():
            for i in attributes:
                if attributes[i][1]+attributes[i][2] == conf['list']:
                    conf['list'] = i
                    break
            if conf['list'] not in attributes.keys():
                sys.exit('Error: '+conf['list']+' wrong attribute.')
        if 'verbose' in conf:
            print 'Lists all the possible values for the following attribute:',conf['list']
    for i in attributes.keys():
        if i in conf:
            if 'verbose' in conf:
                print 'Filter services by the following '+i+':',conf[i]
    
    #arguments
    if 'args' in conf:
        for arg in conf['args']:
            if arg not in attributes.keys():
                cpt = len(conf['args'])
                conf['args'].remove(arg)
                for i in attributes:
                    if attributes[i][1]+attributes[i][2] == arg:
                        conf['args'].append(i)
                        break
                if len(conf['args']) < cpt:
                    sys.exit('Error: '+arg+' is a wrong attribute.')
        conf['args'] = list(set(conf['args'])) # Delete duplicated values
        if 'verbose' in conf:
            if len(conf['args']) > 0:
                print 'The following attributes will be displayed:',' '.join(conf['args'])
            else:
                print 'All the attributes will be displayed.'
    if 'verbose' in conf:
        print 'Verbose mode enabled\n'

def usage():
    """Returns the usage message""" 
    
    return '''Usage: ginfo [options] [attributes]

    List URLs of services along with other optional attributes.

        --host      host        Specify a host to query. By default the
                                environmental variable LCG_GFAL_INFOSYS will be
                                used.
    -l, --list      attribute   List all the possible values of the specified
                                attribute.
    -c, --csv                   Output in CSV format
    -j, --json                  Output in JSON format
    -v, --verbose               Enable verbose mode
    -V, --version               Prints the version of ginfo
    -h, --help                  Prints this helpful message

    Available attributes are:

        cap       EndpointCapability
        domain    ServiceAdminDomainForeignKey
        id        ServiceID
        imp       EndpointImplementationName
        impv      EndpointImplementationVersion
        int       EndpointInterfaceName
        intv      EndpointInterfaceVersion
        ql        EndpointQualityLevel
        type      ServiceType
        url       EndpointURL
        vo        PolicyRule

    Addition options to filter services by the specified attribute:

        --cap       EndpointCapability
    -d, --domain    ServiceAdminDomainForeignKey
    -i, --id        ServiceID
    -m, --imp       EndpointImplementationName
        --impv      EndpointImplementationVersion
    -n, --int       EndpointInterfaceName
        --intv      EndpointInterfaceVersion
    -q, --ql        EndpointQualityLevel
    -t, --type      ServiceType
    -u, --url       EndpointURL
        --vo        PolicyRule'''

def list_usage():
    """Returns the usage message for list option"""

    return '''Available attributes are:

        cap       EndpointCapability
        domain    ServiceAdminDomainForeignKey
        id        ServiceID
        imp       EndpointImplementationName
        impv      EndpointImplementationVersion
        int       EndpointInterfaceName
        intv      EndpointInterfaceVersion
        ql        EndpointQualityLevel
        type      ServiceType
        url       EndpointURL
        vo        PolicyRule'''

def request(filter=None):
    """Returns the result of the ldap request with the filter given"""   
    try:
        l = ldap.initialize('ldap://'+conf['host']+':2170')
        if filter != None:
            result = l.result(l.search('o=glue', ldap.SCOPE_SUBTREE, filter))
        else:
            result = l.result(l.search('o=glue', ldap.SCOPE_SUBTREE))
    except ldap.SERVER_DOWN:
        sys.exit('Error: Can\'t contact the LDAP server. Please check your host.')
    return result[1]

def list_services():
    """Returns a dictionary of the filtered results from an ldap request""" 
    filter = {'Endpoint': ''}
    result = {}
    selection_list = {}
    # Filters 
    for i in attributes:
        if i in conf:
            if attributes[i][0]+attributes[i][1] not in filter:
                filter[attributes[i][0]+attributes[i][1]] = ''
            tmp_filter = '(GLUE2'+attributes[i][1]+attributes[i][2]+'='+conf[i]+')'
            if attributes[i][2] == 'Rule':
                tmp_filter = '(|(GLUE2PolicyRule=ALL)'+tmp_filter+')'
            filter[attributes[i][0]+attributes[i][1]] += tmp_filter

    for i in objectKey.keys():
        if i in filter:
            result[i] = request('(&(objectClass=GLUE2'+i+')'+filter[i]+')')
            selection_list[i] = []
            for r in result[i]:
                selection_list[i].append(r[1]['GLUE2'+i+objectKey[i][0]][0])
    
    result['Endpoint'] = request('(&(objectClass=GLUE2Endpoint)'+filter['Endpoint']+')')
    dic = {} # Final results
    dic2 = {} # Tmp results
    for res in result['Endpoint']:
        iD = {}
        for i in objectKey:
            iD[i] = res[1]['GLUE2'+objectKey[i][1]][0]
        # Executes the filtering by Service and AccessPolicy objects
        stop = False
        for i in objectKey.keys():
            if i in selection_list:
                if iD[i] not in selection_list[i]:
                    stop = True
                    break
        if stop:
            continue
        # Fill in the final results dictionnary
        dic[iD['Service']] = {}
        for attr in conf['args']:
            a1 = attributes[attr][0]+attributes[attr][1]
            a2 = attributes[attr][1]+attributes[attr][2]
            dic[iD['Service']][attr] = None
            if attr in conf and not attributes[attr][3]:
                dic[iD['Service']][attr] = conf[attr]
            else:
                if a1 == 'Endpoint':
                    if 'GLUE2'+a2 in res[1]:
                        dic[iD['Service']][attr] = res[1]['GLUE2'+a2]
                        if not attributes[attr][3]:
                            dic[iD['Service']][attr] = dic[iD['Service']][attr][0]
                else:
                    if a1 not in result:
                        result[a1] = request('(objectClass=GLUE2'+a1+')')
                    if attr not in dic2:
                        dic2[attr] = {}
                        for r in result[a1]:
                            if 'GLUE2'+a2 in r[1]:
                                dic2[attr][r[1]['GLUE2'+a1+objectKey[a1][0]][0]] = r[1]['GLUE2'+a2]
                            else:
                                dic2[attr][r[1]['GLUE2'+a1+objectKey[a1][0]][0]] = None
                    if iD[a1] in dic2[attr]:
                        dic[iD['Service']][attr] = dic2[attr][iD[a1]]
                        if not attributes[attr][3] and dic[iD['Service']][attr]:
                            dic[iD['Service']][attr] = dic[iD['Service']][attr][0]
    if len(dic) == 0 and 'verbose' in conf:
        sys.exit('Error: No result. Verify search parameters.')
    return dic

def list_attr():
    """Returns a list of values for a given attribute""" 
    
    oClass = attributes[conf['list']][0]+attributes[conf['list']][1]
    key = attributes[conf['list']][1]+attributes[conf['list']][2]
    result = request('objectClass=GLUE2'+oClass)
    list = []
    for r in result:
        if 'GLUE2'+key in r[1]:
            if r[1]['GLUE2'+key][0] not in list:
                list.append(r[1]['GLUE2'+key][0])
        else:
            if 'None' not in list:
                list.append('None')
    list.sort()
    return list

def serialize_output(dic):
    """Return the output with the wished format""" 

    if 'csv' in conf:
        list = []
        for i in dic:
            list2 = []
            for j in conf['args']:
                if dic[i][j] == None:
                    list2.append('None')
                elif attributes[j][3]:
                    list2.append('"'+','.join(dic[i][j])+'"')
                else:
                    list2.append(dic[i][j])
            list.append(','.join(list2))
        output = '\n'.join(list)
    elif 'json' in conf:
        output = json.dumps(dic)
    elif 'emi' in conf:
        list = []
        for i in dic:
            dicTmp = {
                "Service_Type": dic[i]['type'],
                "Service_Admin_Domain": dic[i]['domain'],
                "Service_Endpoint_URL": dic[i]['url'],
                "Endpoint_Capability": dic[i]['cap'],
                "Endpoint_Interface_Name": dic[i]['int'],
                "Endpoint_Interface_Version": dic[i]['intv'],
                "Endpoint_Quality_Level": dic[i]['ql']
                }
            list.append(json.dumps(dicTmp))
        output = '['+','.join(list)+']'
    else:
        list = []
        for i in dic:
            for j in conf['args']:
                if dic[i][j] == None:
                    list.append(j+': None')
                elif attributes[j][3]:
                    list.append(j+': '+','.join(dic[i][j]))
                else:
                    list.append(j+': '+dic[i][j])
            list.append('')
        output = '\n'.join(list)
    return output

if __name__ == "__main__":
    main(sys.argv[1:])
