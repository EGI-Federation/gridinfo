#!/usr/bin/env python
##############################################################################
# Copyright (c) CERN, 2012.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at #
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS
# OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##############################################################################

"""Ginfo - Developped by Ivan Calvet for CERN - ivan.calvet@cern.ch"""

import ldap
import sys
import getopt
try:
	import json
except:
	import simplejson as json
import os
import re
import urllib2
import signal
import copy

VERSION = '1.1.0'
TIMEOUT = 60

# flags selected
OPTION = {}
# dictionnary of objects, filters and displayed attributes selected
CONF = {}

# long_flag: [short_flag, parameter_needed]
FLAGS = {
    'host': ["H", True],
    'bind': ["b", True],
    'list': ["l", True],
    'clean': [None, False],
    'strict': ["s", False],
    'csv': ["c", False],
    'json': ["j", False],
    'timeout': ["t", True],
    'verbose': ["v", False],
    'version': ["V", False],
    'help': ["h", False],
    }

# {'object': {'attribute': 'attribute name's for the bdii', ...}, ...}
ELTS = {
'AdminDomain':
    {'ID': 'DomainID',
     'Description': 'DomainDescription'},
'Location':
    {'ID': 'LocationID',
     'Country': 'LocationCountry',
     'Latitude': 'LocationLatitude',
     'Longitude': 'LocationLongitude'},
'Service':
    {'ID': 'ServiceID',
     'Capability': 'ServiceCapability',
     'Type': 'ServiceType',
     'QualityLevel': 'ServiceQualityLevel',
     'StatusInfo': 'ServiceStatusInfo',
     'AdminDomainID': 'ServiceAdminDomainForeignKey'},
'Endpoint':
    {'ID': 'EndpointID',
     'URL': 'EndpointURL',
     'Capability': 'EndpointCapability',
     'InterfaceName': 'EndpointInterfaceName',
     'InterfaceVersion': 'EndpointInterfaceVersion',
     'Implementor': 'EndpointImplementor',
     'ImplementationVersion': 'EndpointImplementationVersion',
     'QualityLevel': 'EndpointQualityLevel',
     'HealthState': 'EndpointHealthState',
     'ServingState': 'EndpointServingState',
     'ServiceID': 'EndpointServiceForeignKey'},
'ComputingShare':
    {'ID': 'ShareID',
     'MaxCPUTime': 'ComputingShareMaxCPUTime',
     'MaxWallTime': 'ComputingShareMaxWallTime',
     'ServingState': 'ComputingShareServingState',
     'RunningJobs': 'ComputingShareRunningJobs',
     'WaitingJobs': 'ComputingShareWaitingJobs',
     'ExecutionEnvironmentID': 'ComputingShareExecutionEnvironmentForeignKey'},
'MappingPolicy':
    {'ID': 'PolicyID',
     'Scheme': 'PolicyScheme',
     'Rule': 'PolicyRule',
     'ComputingShareID': 'MappingPolicyShareForeignKey'},
'GlueCESEBindGroupCEUniqueID':
    {},
'ExecutionEnvironment':
    {'ID': 'ResourceID',
     'OSName': 'ExecutionEnvironmentOSName',
     'ConnectivityOut': 'ExecutionEnvironmentConnectivityOut',
     'MainMemorySize': 'ExecutionEnvironmentMainMemorySize',
     'VirtualMemorySize': 'ExecutionEnvironmentVirtualMemorySize'},
'ComputingManager':
    {'ID': 'ManagerID',
     'ProductName': 'ManagerProductName',
     'ProductVersion': 'ManagerProductVersion',
     'ServiceID': 'ComputingManagerComputingServiceForeignKey'},
'ToComputingService':
    {},
'StorageShare':
    {'ID': 'StorageShareSharingID',
    'Path': 'StorageSharePath',
    'AccessMode': 'StorageShareAccessMode',
    'AccessLatency': 'StorageShareAccessLatency',
    'ServingState': 'StorageShareServingState',
    'RetentionPolicy': 'StorageShareRetentionPolicy',
    'ExpirationMode': 'StorageShareExpirationMode',
    'DefaultLifeTime': 'StorageShareDefaultLifeTime',
    'MaximumLifeTime': 'StorageShareMaximumLifeTime',
    'Tag': 'StorageShareTag'},
'Share':
    {'ID': 'ShareID',
     'ServiceID': 'ShareServiceForeignKey'},
}

def main(argv):
    """Main function that launches the other functions""" 

    parse_options(argv)
    validate_conf()
    if 'list' in OPTION:
        result = list_attributes() # option --list
    else:
        result = list_object() # get all the informations about the specified object
    if 'verbose' in OPTION:
        print ''
    # FIXME: ajouter clean fonction
    # result = clean(result)
    print serialize_output(result)
    sys.exit()

def parse_options(argv):
    """Parse the selected options and put them in a config dictionnary""" 

    # build the good sequence to parse the flags with getopt
    short_flags = ''
    long_flags = [[], []] # Long flags with a short flag, or without
    for i in FLAGS:
        j = 1
        if FLAGS[i][0]:
            j = 0
            short_flags += FLAGS[i][0]
            if FLAGS[i][1]:
                short_flags += ':'
        long_flags[j].append(i)
        if FLAGS[i][1]:
            long_flags[j][-1] += '='
    long_flags = long_flags[0] + long_flags[1]
    # identify flags and put them in the config dictionnary
    try:
        flags, args = getopt.getopt(argv, short_flags, long_flags)
    except getopt.error, err:
        sys.exit(usage())
    for flag, arg in flags:
        flag = flag[flag.rfind('-')+1:]
        for i in FLAGS:
            if flag in (i, FLAGS[i][0]):
                if i not in OPTION:
                    if FLAGS[i][1]:
                        OPTION[i] = arg
                    else:
                        OPTION[i] = True
                    break 
                else:
                    sys.exit("Error: Don't use a flag more than once.")
    
    for arg in args:
        # identify the objects and put it in the config dictionnary
        if arg in ELTS:
            CONF[arg] = {'filter': {}, 'attribute': []}
    for arg in args:
        # identify filters and put them in the config dictionnary
        if '=' in arg:
            if arg.find('.') != -1:
                object = arg[:arg.find('.')]
            else:
                object = CONF.keys()[0]
            filter = arg[arg.find('.')+1:arg.find('=')]
            value = arg[arg.find('=')+1:]
            CONF[object]['filter'][filter] = value
        # all other elements are attributes and are put in the config dictionnary
        elif arg not in ELTS.keys():
            if arg.find('.') != -1:
                object = arg[:arg.find('.')]
            else:
                object = CONF.keys()[0]
            attribute = arg[arg.find('.')+1:]
            CONF[object]['attribute'].append(attribute)

def validate_conf():
    """Prints verbose messages and checks for errors""" 
        
    # options
    if 'help' in OPTION:
        print usage()
        sys.exit()
    if 'version' in OPTION:
        print os.path.basename(sys.argv[0]) +' V'+VERSION
        sys.exit()
    if 'verbose' in OPTION:
        print 'Verbose mode enabled'
    if 'csv' in OPTION and 'json' in OPTION and 'list' not in OPTION:
        sys.exit('Error: choose between csv and json.')
    elif 'csv' in OPTION and 'list' not in OPTION:
        if 'verbose' in OPTION:
            print 'Output in csv formating'
    elif 'json' in OPTION and 'list' not in OPTION:
        if 'verbose' in OPTION:
            print 'Output in json formating'
    if 'host' in OPTION:
        if 'verbose' in OPTION:
            print 'The following host will be used:', OPTION['host']
    else:
        if 'LCG_GFAL_INFOSYS' in os.environ:
            OPTION['host'] = os.environ['LCG_GFAL_INFOSYS']
            if 'verbose' in OPTION:
                print 'The following host will be used:', OPTION['host']
        else:
            sys.exit(usage())
    if 'bind' in OPTION:
        if 'verbose' in OPTION:
            print 'The following binding will be used:', OPTION['bind']
    else:
        OPTION['bind'] = 'o=glue'
        if 'verbose' in OPTION:
            print 'The default binding will be used:', OPTION['bind']
    if 'timeout' in OPTION:
        if 'verbose' in OPTION:
            print 'Ldap timeout has been set to '+OPTION['timeout']+' second(s).'

    # Object
    dicO = {}
    def sortObjects(obj):
        dicO[obj] = [obj]
        for att in ELTS[obj]:
            if att[-2:] == 'ID' and len(att[:-2]) > 0 and att[:-2] in CONF:
                if att[:-2] in dicO:
                    dicO[obj] += dicO[att[:-2]]
                else:
                    dicO[obj] += sortObjects(att[:-2])
        return dicO[obj]
    if not CONF:
        sys.exit('Error: Please specify an object.')
    else:
        if 'verbose' in OPTION:
            if len(CONF) == 1:
                print 'The specified object is '+CONF.keys()[0]+'.'
            else:
                print 'The specified objects are: '+', '.join(CONF.keys())+'.'
        for obj in CONF.keys():
            if obj not in dicO:
                OPTION['objects'] = sortObjects(obj)[::-1]
        if sorted(CONF.keys()) != sorted(OPTION['objects']):
            sys.exit('Error: You can\'t combine these objects.')
    if 'list' in OPTION:
        if len(CONF) > 1:
            sys.exit('Error: You have too many objects.')
        if OPTION['list'] not in ELTS[CONF.keys()[0]]:
            sys.exit('Error: '+OPTION['list']+' is a wrong attribute.')
        if 'verbose' in OPTION:
            print 'List all the possible values for the following attribute:', OPTION['list']

    empty = True
    for obj in CONF:
        # Filters
        if CONF[obj]['filter']:
            for filter in CONF[obj]['filter']:
                if filter not in ELTS[obj]:
                    sys.exit('Error: '+filter+' is not a valid filter.')
            if 'verbose' in OPTION:
                for filter in CONF[obj]['filter']:
                    print 'Filter results by the following '+obj+'.'+filter+':', CONF[obj]['filter'][filter]

        # Attributes
        if CONF[obj]['attribute']:
            for att in CONF[obj]['attribute']:
                if att not in ELTS[obj]:
                    sys.exit('Error: '+att+' is not a valid attribute.')
            empty = False
    for obj in CONF:
        if empty:
            CONF[obj]['attribute'] = ELTS[obj].keys()
        if 'verbose' in OPTION:
            print 'The following attribute(s) of '+obj+' will be displayed:', ', '.join(CONF[obj]['attribute'])

def usage():
    """Returns the usage message""" 
    
    return '''Usage: ginfo [options] Object [attribute_to_filter='value of the attribute'] [attribute_to_display]

    List attributes corresponding to an object. By default, all the attributes of an object are
    displayed.

    [OPTIONS]
    -H, --host      host        Specify a host to query. By default the
                                environmental variable LCG_GFAL_INFOSYS will be
                                used.
    -b, --bind      binding     Specify the binding (o=glue by default).
    #-l, --list      attribute   List all the possible values of the specified
                                attribute.
    #-c, --csv                   Output in CSV format
    #-j, --json                  Output in JSON format
    -t, --timeout               Change the ldap timeout (15 seconds by default).
    -v, --verbose               Enable verbose mode
    -V, --version               Print the version of ginfo
    -h, --help                  Print this helpful message

    [OBJECTS AND CORRESPONDING ATTRIBUTES]
        AdminDomain:
            ID, Description.
        ComputingManager:
            ID, ProductName, ProductVersion, ServiceID.
        ComputingShare:
            ID, MaxCPUTime, MaxWallTime, ServingState, 
            RunningJobs, WaitingJobs, ExecutionEnvironmentID.
        Endpoint:
            ID, URL, Capability, InterfaceName, InterfaceVersion, Implementor, 
            ImplementationVersion, QualityLevel, HealthState, ServingState, 
            ServiceID.
        ExecutionEnvironment:
            ID, OSName, ConnectivityOut, MainMemorySize, VirtualMemorySize.
        Location:
            ID, Country, Latitude, Longitude.
        MappingPolicy:
            ID, Scheme, Rule, ComputingShareID.
        Service:
            ID, Capability, Type, QualityLevel, StatusInfo, AdminDomainID.
        StorageShare:
            ID, Path, AccessMode, AccessLatency, ServingState, RetentionPolicy,
            ExpirationMode, DefaultLifeTime, MaximumLifeTime, Tag.
'''

def handler(signum, frame):
    sys.exit('Error: Timeout to contact the LDAP server.')

def request(filter=None):
    """Returns the result of the ldap request with the filter given"""

    try:
        t = int(OPTION['timeout'])
    except (ValueError, KeyError):
        t = TIMEOUT
    signal.signal(signal.SIGALRM, handler)
    signal.alarm(t)
    if 'host' in OPTION:
        try:
            port = ''
            if ':' not in OPTION['host']:
                port = ':2170'
            con = ldap.initialize('ldap://'+OPTION['host']+port)
            if filter:
                result = con.result(con.search(OPTION['bind'], ldap.SCOPE_SUBTREE, filter))[1]
            else:
                result = con.result(con.search(OPTION['bind'], ldap.SCOPE_SUBTREE))[1]
        except ldap.SERVER_DOWN:
            sys.exit('Error: Can\'t contact the LDAP server. Please check your host.')
    return result

def list_object():
    """Returns a dictionary of filtered results from a ldap request""" 

    dic = {} # Store the final results
    for obj in OPTION['objects']:
        dic[obj] = {} # Create a dictionnary for each object

        # Construct the filter
        filter = ''
        for f in CONF[obj]['filter']:
            filter += '(GLUE2'+ELTS[obj][f] + '=' + CONF[obj]['filter'][f] + ')'

        # Main loop
        result = request('(&(objectClass=GLUE2' + obj + ')' + filter + ')')

        for res in result:
            id = res[1]['GLUE2' + ELTS[obj]['ID']][0] # ID of the entry
            if id not in dic[obj]:
                dic[obj][id] = {} # Creates a dictionnary for each ID of an object
                dic[obj][id][obj] = {}
            for att in ELTS[obj]:
                realID = 'GLUE2' + ELTS[obj][att] # Real ID of each attributes
                if realID in res[1]:
                    dic[obj][id][obj][att] = res[1][realID] # Affects the value
                else:
                    dic[obj][id][obj][att] = None
            if len(dic) > 1: # If an other object has already been requested
                for att in ELTS[obj]:
                    foreignObject = att[:-2]
                    if att[-2:] == 'ID' and len(att) != 2 and foreignObject in OPTION['objects']: # For each foreignkey
                        realID = 'GLUE2' + ELTS[obj][att]
                        foreignKey = res[1][realID][0]
                        if foreignKey in dic[foreignObject]:
                            for a in dic[foreignObject][foreignKey]:
                                dic[obj][id][a] = dic[foreignObject][foreignKey][a]
    return dic[OPTION['objects'][-1]]

# FIXME: A fixer plus tard
def list_attributes():
    """Returns a list of values for a given attribute""" 
    
    id = 'GLUE2' + ELTS[CONF['object'][0]][OPTION['list']]
    result = request('objectClass=GLUE2' + CONF['object'][0])
    attr_list = []
    for res in result:
        if id in res[1]:
            for att in res[1][id]:
                if att not in attr_list:
                    attr_list.append(att)
        else:
            if 'None' not in attr_list:
                attr_list.append('None')
    attr_list.sort()
    return attr_list

# FIXME: options list, csv, json
def serialize_output(result):
    """Return the output with the wished format""" 

    if 'list' in OPTION:
        output = '\n'.join(result)
    elif 'csv' in OPTION:
        csv_list = []
        titles = []
        for att in CONF['attribute']:
           titles.append(att) 
        csv_list.append(','.join(titles))
        for id in result:
            tmp_list = []
            for att in CONF['attribute']:
                if result[id][att] == None:
                    tmp_list.append('None')
                elif len(result[id][att]) > 1:
                    tmp_list.append('"'+','.join(result[id][att])+'"')
                else:
                    tmp_list.append(result[id][att][0])
            csv_list.append(','.join(tmp_list))
        output = '\n'.join(csv_list)
    elif 'json' in OPTION:
        output = json.dumps(result)
    else:
        output_list = []
        for id in result:
            if 'strict' in OPTION and len(result[id]) != len(OPTION['objects']):
                continue
            for obj in result[id]:
                for att in result[id][obj]:
                    if not CONF[obj]['attribute'] or att in CONF[obj]['attribute']:
                        if not result[id][obj][att]:
                            output_list.append(obj+'.'+att+': None')
                        else:
                            output_list.append(obj+'.'+att+': '+', '.join(result[id][obj][att]))
            output_list.append('')
        output = '\n'.join(output_list)
    return output

if __name__ == "__main__":
    main(sys.argv[1:])
